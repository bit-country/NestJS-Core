import { Logger, NotFoundException } from '@nestjs/common';
import { FilterQuery, Model, UpdateQuery } from 'mongoose';
import { AbstractDocument, AutoGeneratedField } from './abstract.schema';

export abstract class AbstractRepository<TDocument extends AbstractDocument> {
  protected abstract readonly logger: Logger;

  protected constructor(protected readonly model: Model<TDocument>) {}

  // private projectResult(doc: TDocument) {
  //   const docResp = {
  //     ...doc,
  //     id: doc._id
  //   }

  //   delete docResp._id;
  //   delete docResp._updatedAt;
  //   delete docResp._createdAt;

  //   return transform(docResp, (result, val, key) => {
  //     result[key.charAt(0).toLowerCase() + key.slice(1)] = val;
  //   });
  // }

  async create(
    createDto: Omit<TDocument, AutoGeneratedField>,
  ): Promise<TDocument> {
    const createdDocument = new this.model(createDto);
    return (await createdDocument.save()).toJSON() as TDocument;
    // const result = (await createdDocument.save()).toJSON() as TDocument;
    // if (!result) this.handleNotFoundError({});

    // return this.projectResult(result);
  }

  async findOne(filterQuery: FilterQuery<TDocument>): Promise<TDocument> {
    const document = await this.model.findOne(filterQuery, {}, { lean: true });
    if (!document) this.handleNotFoundError(filterQuery);

    return document as TDocument;
    // return this.projectResult(document as TDocument);
  }

  async findById(id: string): Promise<TDocument> {
    const document = await this.model.findById(id, {}, { lean: true });
    if (!document) this.handleNotFoundError({ _id: id });

    return document as TDocument;
    // return this.projectResult(document as TDocument);
  }

  async findOneAndUpdate(
    filterQuery: FilterQuery<TDocument>,
    update: UpdateQuery<TDocument>,
  ): Promise<TDocument> {
    const document = await this.model.findOneAndUpdate(filterQuery, update, {
      lean: true,
      new: true,
    });
    if (!document) this.handleNotFoundError(filterQuery);

    return document as TDocument;
    // return this.projectResult(document as TDocument);
  }

  async findIdAndUpdate(
    id: string,
    update: UpdateQuery<TDocument>,
  ): Promise<TDocument> {
    const document = await this.model.findByIdAndUpdate(id, update, {
      lean: true,
      new: true,
    });

    if (!document) this.handleNotFoundError({ _id: id });
    return document as TDocument;
    // return this.projectResult(document as TDocument);
  }

  async find(filterQuery?: FilterQuery<TDocument>): Promise<TDocument[]> {
    const document = await this.model.find(filterQuery, {}, { lean: true });
    if (!document) this.handleNotFoundError(filterQuery);

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    // const docsResp = []
    // for (const doc of document as TDocument[]) {
    //   docsResp.push(this.projectResult(doc));
    // }
    // return docsResp;
    return document as TDocument[];
  }

  async findByPagination(
    filterQuery?: FilterQuery<TDocument>,
    sortName = '_id',
    skip: number = 0,
    limit: number = 1000,
  ): Promise<TDocument[]> {
    const document = await this.model
      .find(filterQuery, {}, { lean: true })
      .sort({ [sortName]: -1 })
      .skip(skip)
      .limit(limit);
    if (!document) this.handleNotFoundError(filterQuery);

    // const docsResp = []
    // for (const doc of document as TDocument[]) {
    //   docsResp.push(this.projectResult(doc));
    // }
    // return docsResp;

    return document as TDocument[];
  }

  async findOneAndDelete(filterQuery: FilterQuery<TDocument>): Promise<any> {
    const document = await this.model.findOneAndDelete(filterQuery).lean();

    if (!document) this.handleNotFoundError(filterQuery);
    // const docResp = this.projectResult(document as TDocument);
    return {
      message: 'Document deleted successfully',
      data: document,
    };
  }

  async findIdAndDelete(id: string): Promise<any> {
    const document = await this.model.findByIdAndDelete(id).lean();

    if (!document) this.handleNotFoundError({ _id: id });
    // const docResp = this.projectResult(document as TDocument);
    return {
      message: 'Document deleted successfully',
      data: document,
    };
  }

  async countDocument(filterQuery: FilterQuery<TDocument>): Promise<number> {
    return await this.model.countDocuments(filterQuery);
  }

  protected handleNotFoundError(filterQuery: FilterQuery<TDocument>) {
    this.logger.warn(
      `Document not found for filter query: ${JSON.stringify(filterQuery)}`,
    );
    throw new NotFoundException('Document not found');
  }
}
